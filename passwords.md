<form name="generator" onsubmit="javascript: return false;">
<dl>
<dt>bookmark</dt>
<dd id="bookmark"></dd>
<dt>initial template</dt>
<dd>
<input name="initial_template" size="64" type="text">
</dd>
<dt>next template</dt>
<dd>
<input name="next_template" type="text">
</dd>
<dt>user</dt>
<dd>
<input name="user" type="text">
</dd>
<dt>host</dt>
<dd>
<input name="host" type="text">
</dd>
<dt>secret</dt>
<dd>
<input name="secret" type="password">
<input name="secret_confirm" type="password">
<input name="clear" value="clear" type="button">
<span id="confirmed">confirmed</span>
</dd>
<dt>output</dt>
<dd>
<input name="output" type="password">
<input name="show" value="true" type="checkbox">show
</dd>
<dt>search key</dt>
<dd>
<input name="search" type="password">
<input name="seek" value="seek" type="button">
</dd>
<dt>max seek count</dt>
<dd>
<input name="maxseekcount" value="1" type="text">
</dd>
<dt>count</dt>
<dd>
<pre id="count">0</pre>
</dd>
<dt>salt</dt>
<dd>
<input name="salt" type="text">
</dd>
<dt>messages</dt>
<dd>
<pre id="messages"></pre>
</dd>
</dl>
<input name="prev" value="prev" type="button">
<input name="next" value="next" type="button">
<input name="reset" value="reset" type="button">
</form>

<hr/>

NAME
====
passwords.html - a password sequence generator

DESCRIPTION
===========
This file is a standalone HTML file that contains a password sequence generator.

Initial passwords are generated by substituting tokens into the initial template, appending \n, calculating
the md5 hash of the resulting string. The output is the left-most 8 hex-digits of the
resulting md5 sum. The default initial template is: ${user}:${secret}@${host}${salt}.

To use the generator to generate an initial password, enter a user or account name in the user field, a host or domain name
in the host field and a secret in the secret field. Use the 2nd secret field to confirm the secret. Then hit next. To see
the generted password, check the "show" checkbox.

Subsequent passwords are generated in the same way, this time using the next template as the template.
The next template can reference the previously generated output using the ${output} parameter reference. 
The default next template: is ${output}${secret}${salt}.

Templates are arbitrary strings which may optionally contain parameter reference markers. The supported 
parameters are: user, host, salt, secret and output. The output parameter is only useful in the next template.

The generated bookmark links can be saved in a browser. 

USAGE SCENARIOS
===============
Site-Specific Passwords
-----------------------
Instead of using a low-value password across multiple sites, generate a different password for each
site. Provided you keep your secret secure, compromise of one site's password database won't have
implications for accounts at other sites.

Password Renewal
----------------
Some sites force you to change the password periodically. It can be hard to remember the new password but
you usually can remember the old password. If you assign passwords from the sequence, you can usually find
the next password in your sequence simply by regenerating it.

Password Recovery
-----------------
On test and development systems it is common practice to share the same password across multiple systems 
even though this is against recommended best practice. However, unless passwords are regularly maintained,
less frequently used accounts may still use an older password. If you assign passwords from a sequence
you may be able to recover the password from the sequence.

INSTALLATION
============
1. save this file to your local disk
2. verify that your copy of passwords.html matches the MD5 sum of a trusted version of this file.
3. open that copy in your browser
4. optionally, modify the salt to some public, but arbitrary value
5. save the generated bookmark as a link 

SECURITY CONSIDERATIONS
=======================
The passwords generated by passwords.html may be secure provided:

* your secret is never compromised
* you only use this page in a trusted browser
* you only load this page from a trusted source
* you are using a secure transport to load this page
* your bookmark store is secure

If any of these assumptions are not true, then your generated passwords will be easily compromised. 

In particular, man in the middle attacks will be trivial if an attacker can do enough to convince
you to load a maliciously altered copy of this page.

Rainbow table attacks on the secret may be mitigated somewhat by salting the template with a non-blank
${salt} parameter.

VERSIONS
========
* <a href="passwords.md5">Current version MD5</a>.
* <a href="versions.txt">Previous versions.</a>

AUTHOR
======
Copyright (C) Jon Seymour 2011<br/>
MD5 implementation Copyright (C) Paul Johnston, et al. 1999 - 2009

ACKNOWLEDGEMENTS
================
passwords.html makes use of <a href="http://pajhome.org.uk/crypt/md5">Paul Johnson's JavaScript MD5 implementation</a>.

<script type="text/javascript">
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2-beta Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

</script>

<script type="text/javascript">
(function(){
   var form = document.forms["generator"];
   var messagePanel = document.getElementById("messages");
   var countPanel = document.getElementById("count");
   var bookmarkPanel = document.getElementById("bookmark");
   var confirmedPanel = document.getElementById("confirmed");
   var title = document.getElementById("title");
   var message="";
   var output="";
   var maxseekcount=1024;
   var count=0;
   var search;

   function read_form()
   {
      output=form['output'].value;
      maxseekcount=parseInt(form.maxseekcount.value);
      search=form['search'].value;
   }

   function update_form()
   {
      if (form.show.checked) {
         form['output'].type="text";
      } else {
         form['output'].type="password";
      }
      if (form.secret.value == form.secret_confirm.value) {
         confirmedPanel.innerHTML='confirmed'
      } else {
         confirmedPanel.innerHTML='not confirmed'
      }
      form.maxseekcount.value=maxseekcount;
      form.output.value=output;
      countPanel.innerHTML=count;
      messagePanel.innerHTML=message;
      bookmarkPanel.innerHTML="<a alt='bookmark' href='"+bookmark_url()+"'>"+bookmark_title()+"</a>";
      title.innerHTML=bookmark_title();
   }

   function bookmark_url()
   {
      var x=location.href.indexOf('?');
      var uri=x >= 0 ? location.href.substring(0,x) : location.href;
      return uri
		  +"?initial_template="+form.initial_template.value
		  +"&next_template="+form.next_template.value
		  +"&host="+form.host.value
		  +"&user="+form.user.value
		  +"&salt="+form.salt.value;
   }

   function bookmark_title()
   {
      var tmp="password generator"
      if (form.user.value != '') {
          tmp = tmp + " for " + form.user.value
      }
      if (form.host.value != '') {
          tmp = tmp + " @ " + form.host.value
      }
      return tmp;
   }

   function cycle()
   {
      var template = 
        (output=='') 
        ? form.initial_template.value      
        : form.next_template.value;
      var tmp;

      if (output!='') {
         tmp=form.next_template.value.replace('\${secret}', form.secret.value);
         tmp=tmp.replace('\${output}', output);
      } else {
         tmp=form.initial_template.value.replace('\${secret}', form.secret.value);
      }

      tmp=tmp.replace('\${user}', form.user.value);
      tmp=tmp.replace('\${salt}', form.salt.value);
      tmp=tmp.replace('\${host}', form.host.value);

      output=hex_md5(tmp+'\n').substring(0,8);
      count=count+1;
   }

   form.next.onclick=function() {
      read_form();
      cycle();
      update_form();
      return false;
   };


   form.prev.onclick=function() {
      read_form();
      maxseekcount=count > 0 ? count-1 : 0;
      count=0;
      output='';
      while (count < maxseekcount) {
         cycle();
      }
      update_form();
      return false;
   };

   form.seek.onclick=function() {
      read_form();
      if (count >= maxseekcount) {
         message="to go further, adjust max count";
      } else {
         while (count < maxseekcount && (output != search || search == '') ) {
            cycle();
         }
      }
      update_form();
   }

   form.reset.onclick=function() {
      count=0;
      maxseekcount=1024;
      output='';
      message='';
      update_form();
      return false;
   };

   form.clear.onclick=function() {
      form.secret.value='';
      form.secret_confirm.value='';
      read_form();
      update_form();
      return false;
   };

   form.search.onblur=update_form;			
   form.show.onchange=update_form;
   form.user.onblur=update_form;
   form.host.onblur=update_form;
   form.salt.onblur=update_form;
   form.secret.onblur=update_form;
   form.secret_confirm.onblur=update_form;

   function read_param(p,d)
   {
      var x=location.href.indexOf(p+"=");
      if (x>=0) {
         var y=location.href.indexOf('&', x+1);
         return y >= 0 ? location.href.substring(x+p.length+1,y) : location.href.substring(x+p.length+1);
      } else if (d) {
         return d;
      } else {
         return "";
      }
    
   }

   form.host.value=read_param('host');
   form.user.value=read_param('user');
   form.salt.value=read_param('salt');
   form.initial_template.value=read_param('initial_template', "${user}:${secret}@${host}${salt}");
   form.next_template.value=read_param('next_template', "${output}${secret}${salt}");

   update_form();

})();
</script>
